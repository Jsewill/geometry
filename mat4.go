/* */
package geometry

type Mat4x1 [4]Mat1x1

func (m Mat4x1) Len() int {
	return 4
}

func (m Mat4x1) Multiply(v Vec1) Vec4 {
	return Vec4{
		m[0][0] * v[0],
		m[1][0] * v[0],
		m[2][0] * v[0],
		m[3][0] * v[0],
	}
}

func (m Mat4x1) Transpose() Mat1x4 {
	return Mat1x4{m[0][0], m[1][0], m[2][0], m[3][0]}
}

type Mat4x2 [4]Mat1x2

func (m Mat4x2) Len() int {
	return 8
}

func (m Mat4x2) Multiply(v Vec2) Vec4 {
	return Vec4{
		m[0][0]*v[0] + m[0][1]*v[1],
		m[1][0]*v[0] + m[1][1]*v[1],
		m[2][0]*v[0] + m[2][1]*v[1],
		m[3][0]*v[0] + m[3][1]*v[1],
	}
}

func (m Mat4x2) Transpose() Mat2x4 {
	return Mat2x4{
		Mat1x4{m[0][0], m[1][0], m[2][0], m[3][0]},
		Mat1x4{m[0][1], m[1][1], m[2][1], m[3][1]},
	}
}

type Mat4x3 [4]Mat1x3

func (m Mat4x3) Len() int {
	return 12
}

func (m Mat4x3) Multiply(v Vec3) Vec4 {
	return Vec4{
		m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
		m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
		m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2],
		m[3][0]*v[0] + m[3][1]*v[1] + m[3][2]*v[2],
	}
}

func (m Mat4x3) Transpose() Mat3x4 {
	return Mat3x4{
		Mat1x4{m[0][0], m[1][0], m[2][0], m[3][0]},
		Mat1x4{m[0][1], m[1][1], m[2][1], m[3][1]},
		Mat1x4{m[0][2], m[1][2], m[2][2], m[3][2]},
	}
}

type Mat4x4 [4]Mat1x4

func (m Mat4x4) Determinant() float64 {
	return m[0][0]*m[1][1]*m[2][2]*m[3][3] + m[0][0]*m[1][2]*m[2][3]*m[3][1] + m[0][0]*m[1][3]*m[2][1]*m[3][2] - m[0][0]*m[1][3]*m[2][2]*m[3][1] - m[0][0]*m[1][2]*m[2][1]*m[3][3] - m[0][0]*m[1][1]*m[2][3]*m[3][2] - m[0][1]*m[1][0]*m[2][2]*m[3][3] + m[0][1]*m[1][2]*m[2][3]*m[3][0] + m[0][1]*m[1][3]*m[2][0]*m[3][2] - m[0][1]*m[1][3]*m[2][2]*m[3][0] - m[0][1]*m[1][2]*m[2][0]*m[3][3] - m[0][1]*m[1][1]*m[2][3]*m[3][2] + m[0][2]*m[1][0]*m[2][1]*m[3][3] + m[0][2]*m[1][1]*m[2][3]*m[3][0] + m[0][2]*m[1][3]*m[2][0]*m[3][1] - m[0][2]*m[1][3]*m[2][1]*m[3][0] - m[0][2]*m[1][1]*m[2][0]*m[3][3] - m[0][2]*m[1][1]*m[2][3]*m[3][1] - m[0][3]*m[1][0]*m[2][1]*m[3][2] + m[0][3]*m[1][1]*m[2][2]*m[3][0] + m[0][3]*m[1][2]*m[2][0]*m[3][1] - m[0][3]*m[1][2]*m[2][1]*m[3][0] - m[0][3]*m[1][1]*m[2][0]*m[3][2] - m[0][3]*m[1][1]*m[2][2]*m[3][1]
}

func (m Mat4x4) Inverse() Mat4x4 {
	//Determinant
	d := m[0][0]*m[1][1]*m[2][2]*m[3][3] + m[0][0]*m[1][2]*m[2][3]*m[3][1] + m[0][0]*m[1][3]*m[2][1]*m[3][2] - m[0][0]*m[1][3]*m[2][2]*m[3][1] - m[0][0]*m[1][2]*m[2][1]*m[3][3] - m[0][0]*m[1][1]*m[2][3]*m[3][2] - m[0][1]*m[1][0]*m[2][2]*m[3][3] + m[0][1]*m[1][2]*m[2][3]*m[3][0] + m[0][1]*m[1][3]*m[2][0]*m[3][2] - m[0][1]*m[1][3]*m[2][2]*m[3][0] - m[0][1]*m[1][2]*m[2][0]*m[3][3] - m[0][1]*m[1][1]*m[2][3]*m[3][2] + m[0][2]*m[1][0]*m[2][1]*m[3][3] + m[0][2]*m[1][1]*m[2][3]*m[3][0] + m[0][2]*m[1][3]*m[2][0]*m[3][1] - m[0][2]*m[1][3]*m[2][1]*m[3][0] - m[0][2]*m[1][1]*m[2][0]*m[3][3] - m[0][2]*m[1][1]*m[2][3]*m[3][1] - m[0][3]*m[1][0]*m[2][1]*m[3][2] + m[0][3]*m[1][1]*m[2][2]*m[3][0] + m[0][3]*m[1][2]*m[2][0]*m[3][1] - m[0][3]*m[1][2]*m[2][1]*m[3][0] - m[0][3]*m[1][1]*m[2][0]*m[3][2] - m[0][3]*m[1][1]*m[2][2]*m[3][1]

	//Invertible? @TODO: Implement an approximate equality test to avoid false positives due to inherent floating point math variances.
	if d == 0 {
		return Mat4x4{}
	}

	d = 1.0 / d

	//Return the transpose of the matrix of the determinants of each sub matrix.
	return Mat4x4{
		Mat1x4{
			d * (m[1][1]*m[2][2]*m[3][3] + m[1][2]*m[2][3]*m[3][1] + m[1][3]*m[2][1]*m[3][2] - m[1][1]*m[2][3]*m[3][2] - m[1][2]*m[2][1]*m[3][3] - m[1][3]*m[2][2]*m[3][1]),
			d * (m[0][1]*m[2][3]*m[3][2] + m[0][2]*m[2][1]*m[3][3] + m[0][3]*m[2][2]*m[3][1] - m[0][1]*m[2][2]*m[3][3] - m[0][2]*m[2][3]*m[3][1] - m[0][3]*m[2][1]*m[3][2]),
			d * (m[0][1]*m[1][2]*m[3][3] + m[0][2]*m[1][3]*m[3][1] + m[0][3]*m[1][1]*m[3][2] - m[0][1]*m[1][3]*m[3][2] - m[0][2]*m[1][1]*m[3][3] - m[0][3]*m[1][2]*m[3][1]),
			d * (m[0][1]*m[1][3]*m[2][2] + m[0][2]*m[1][1]*m[2][3] + m[0][3]*m[1][2]*m[2][1] - m[0][1]*m[1][2]*m[2][3] - m[0][2]*m[1][3]*m[2][1] - m[0][3]*m[1][1]*m[2][2]),
		},
		Mat1x4{
			d * (m[1][0]*m[2][3]*m[3][2] + m[1][2]*m[2][0]*m[3][3] + m[1][3]*m[2][2]*m[3][0] - m[1][0]*m[2][2]*m[3][3] - m[1][2]*m[2][3]*m[3][0] - m[1][3]*m[2][0]*m[3][2]),
			d * (m[0][0]*m[2][2]*m[3][3] + m[0][2]*m[2][3]*m[3][1] + m[0][3]*m[2][0]*m[3][2] - m[0][0]*m[2][3]*m[3][2] - m[0][2]*m[2][0]*m[3][3] - m[0][3]*m[2][2]*m[3][0]),
			d * (m[0][0]*m[1][3]*m[3][2] + m[0][2]*m[1][0]*m[3][3] + m[0][3]*m[1][2]*m[3][0] - m[0][0]*m[1][2]*m[3][3] - m[0][2]*m[1][3]*m[3][0] - m[0][3]*m[1][0]*m[3][2]),
			d * (m[0][0]*m[1][2]*m[2][3] + m[0][2]*m[1][3]*m[2][0] + m[0][3]*m[1][0]*m[2][2] - m[0][0]*m[1][3]*m[2][2] - m[0][2]*m[1][0]*m[2][3] - m[0][3]*m[1][2]*m[2][0]),
		},
		Mat1x4{
			d * (m[1][0]*m[2][1]*m[3][3] + m[1][1]*m[2][3]*m[3][0] + m[1][3]*m[1][0]*m[2][2] - m[1][0]*m[2][3]*m[3][1] - m[1][1]*m[2][0]*m[3][3] - m[1][3]*m[2][1]*m[3][0]),
			d * (m[0][0]*m[2][3]*m[3][1] + m[0][1]*m[2][0]*m[3][3] + m[0][3]*m[2][1]*m[3][0] - m[0][0]*m[2][1]*m[3][3] - m[0][1]*m[2][3]*m[3][0] - m[0][3]*m[2][0]*m[3][1]),
			d * (m[0][0]*m[1][1]*m[3][3] + m[0][1]*m[1][3]*m[3][0] + m[0][3]*m[1][0]*m[3][1] - m[0][0]*m[1][3]*m[3][1] - m[0][1]*m[1][0]*m[3][3] - m[0][3]*m[1][1]*m[3][0]),
			d * (m[0][0]*m[1][3]*m[2][1] + m[0][1]*m[1][0]*m[2][3] + m[0][3]*m[1][1]*m[2][0] - m[0][0]*m[1][1]*m[2][3] - m[0][1]*m[1][3]*m[2][0] - m[0][3]*m[1][0]*m[2][1]),
		},
		Mat1x4{
			d * (m[1][0]*m[2][2]*m[3][1] + m[1][1]*m[2][0]*m[3][2] + m[1][2]*m[2][0]*m[3][2] - m[1][0]*m[2][1]*m[3][2] - m[1][1]*m[2][2]*m[3][0] - m[1][2]*m[2][0]*m[3][1]),
			d * (m[0][0]*m[2][1]*m[3][2] + m[0][1]*m[2][2]*m[3][0] + m[0][2]*m[2][0]*m[3][1] - m[0][0]*m[2][2]*m[3][1] - m[0][1]*m[2][0]*m[3][2] - m[0][2]*m[2][1]*m[3][0]),
			d * (m[0][0]*m[1][2]*m[3][1] + m[0][1]*m[1][0]*m[3][2] + m[0][2]*m[1][1]*m[3][0] - m[0][0]*m[1][1]*m[3][2] - m[0][1]*m[1][2]*m[3][0] - m[0][2]*m[1][0]*m[3][1]),
			d * (m[0][0]*m[1][1]*m[2][2] + m[0][1]*m[1][2]*m[2][0] + m[0][2]*m[1][0]*m[2][1] - m[0][0]*m[1][2]*m[2][1] - m[0][1]*m[1][0]*m[2][2] - m[0][2]*m[1][1]*m[2][0]),
		},
	}

	return Mat4x4{
		Mat1x4{},
		Mat1x4{},
		Mat1x4{},
		Mat1x4{},
	}
}

func (m Mat4x4) Len() int {
	return 16
}

func (m Mat4x4) Multiply(v Vec4) Vec4 {
	return Vec4{
		m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2] + m[0][3]*v[3],
		m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2] + m[1][3]*v[3],
		m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2] + m[2][3]*v[3],
		m[3][0]*v[0] + m[3][1]*v[1] + m[3][2]*v[2] + m[3][3]*v[3],
	}
}

func (m Mat4x4) Transpose() Mat4x4 {
	return Mat4x4{
		Mat1x4{m[0][0], m[1][0], m[2][0], m[3][0]},
		Mat1x4{m[0][1], m[1][1], m[2][1], m[3][1]},
		Mat1x4{m[0][2], m[1][2], m[2][2], m[3][2]},
		Mat1x4{m[0][3], m[1][3], m[2][3], m[3][3]},
	}
}
